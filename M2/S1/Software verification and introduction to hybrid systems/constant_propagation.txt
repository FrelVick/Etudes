TYPE

  ConstFlattened = flat(snum)
  BoolFlattened  = flat(bool)
  bounds         = snum * snum
  Interval       = flat(bounds)
  State          = Var -> Interval


PROBLEM Constant_Propagation

  direction  : forward
  carrier    : State
  init       : bot
  init_start : [-> top]
  combine    : lub


TRANSFER

// in assignments calculate the new value of the variable and add it to the state
  ASSIGN(variable, expression) = if (@ = bot) then @ else
      @\[variable -> evalAExp(expression, @)] endif

// in procedur calls pass the value of the actual argument to the formal parameter
  CALL(_, param, exp), call_edge =
      @\[param -> evalAExp(exp, @)]

  CALL(_, _, _), local_edge = bot

  // at the end of procedures reset the formal parameter
  END(_, param) =
      @\[param -> top]

  // test conditions
  IF(expression), true_edge = branch(expression,@,true)

  IF(expression), false_edge = branch(expression,@,false)

  // loop conditions
  WHILE(expression), true_edge = branch(expression,@,true)

  WHILE(expression), false_edge = branch(expression,@,false)


SUPPORT

  evalAExp :: Expression * State -> Interval
  evalAExp(expression, state) =
    case expType(expression) of
      "ARITH_BINARY" =>
        let valLeft  = evalAExp(expSubLeft(expression), state), valRight = evalAExp(expSubRight(expression), state) in
          case expOp(expression) of
            "+" => addinterval(valLeft,valRight);
            "-" => subinterval(valLeft,valRight);
            "*" => multinterval(valLeft,valRight);
            "/" => if intersectioninterval(valRight,(lift(0),lift(0))) != (top,bot)
                    then (bot,top)
                    else divinterval(valLeft,valRight)
                   endif;
          endcase;
      "ARITH_UNARY" =>
        case expOp(expression) of
          "-" =>  let value <= evalAExp(expSub(expression), state) in
                    multinterval(value,lift(-1,-1));
        endcase;
      "VAR"   =>  state ( expVar(expression) );
      "CONST" =>  (lift(expVal(expression)),lift(expVal(expression)));
      _       => error("Runtime Error: evalAExp applied to nonarithmetic Expression");
    endcase

  evalBExp :: Expression * State -> BoolFlattened
  evalBExp(expression,state) =
    case expType(expression) of
      "TRUE" => lift(true);
      "FALSE" => lift(false);
      /*"BOOL_UNARY" => let value <= evalBExp(expSub(expression), state) in lift(!value);
       "BOOL_BINARY" => case expOp(expression) of
         "<" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft < valRight);
         "<=" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft <= valRight);
         ">" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft > valRight);
         ">=" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft >= valRight);
         "=" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft = valRight);
         "<>" => let valLeft  <= evalAExp(expSubLeft(expression),  state),
                   valRight <= evalAExp(expSubRight(expression), state) in
                 lift(valLeft != valRight);
         endcase;*/
       _ => top;
     endcase

  // TODO: check corner cases
  addinterval :: Interval * Interval -> Interval
  addinterval(valLeft, valRight) =
    case valLeft, valRight of
      bot, _   => bot;
      _  , bot => bot;
      top, _   => top;
      _  , top => top;
      _  , _   => let left = drop(valLeft), right = drop(valRight) in
                    lift(left#1 + right#2, left#2 + right#1);
    endcase

  // TODO: corner cases
  subinterval :: Interval * Interval -> Interval
  subinterval(valLeft, valRight) =
    case valLeft, valRight of
      bot, _   => bot;
      _  , bot => bot;
      top, _   => top;
      _  , top => top;
      _  , _   => let left = drop(valLeft), right = drop(valRight) in
                    lift(left#1 - right#2, left#2 - right#1);
    endcase

  // TODO: corner cases
  multinterval :: Interval * Interval -> Interval
  multinterval(valLeft, valRight) =
    case valLeft, valRight of
      bot, _   => bot;
      _  , bot => bot;
      top, _   => top;
      _  , top => top;
      _  , _   => let left = drop(valLeft), right = drop(valRight) in
                  let x1 = left#1, x2 = left#2, x3 = right#1, x4 = right#2 in
                    lift(min(min(min(x1*x3, x1*x4), x2*x3), x2*x4),max(max(max(x1*x3, x1*x4), x2*x3), x2*x4));
    endcase

  // TODO
  divinterval :: Interval * Interval -> Interval
  divinterval(valLeft, valRight) =
    case valLeft, valRight of
      top, _   => (top, top);
      _  , top => (top, top);
      bot, _   => (bot, bot);
      _  , bot => (bot, bot);
      _  , _   => if intersectioninterval(valRight,lift(0,0)) != bot then top else 
                    let left = drop(valLeft), right = drop(valRight) in
                      let x1 = left#1, x2 = left#2, x3 = right#1, x4 = right#2 in
                        lift(min(min(min(x1/x3, x1/x4), x2/x3), x2/x4),max(max(max(x1/x3, x1/x4), x2/x3), x2/x4));
                  endif
    endcase

  // TODO: handle corner cases?
  intersectioninterval :: Interval * Interval -> Interval
  intersectioninterval(valLeft, valRight) =
    case valLeft, valRight of
      bot, _   => bot;
      _  , bot => bot;
      top, _   => top;
      _  , top => top;
      _  , _   => let left = drop(valLeft), right = drop(valRight) in
                    let x1 = left#1, x2 = left#2, x3 = right#1, x4 = right#2 in
                      if (x3>x2 || x1>x4) then bot else
                        lift(max(left#1, right#1), min(left#2, right#2))
                      endif;
    endcase

  // TODO: handle corner cases?
  unioninterval :: Interval * Interval -> Interval
  unioninterval(valLeft, valRight) =
  case valLeft, valRight of
      bot, _   => bot;
      _  , bot => bot;
      top, _   => top;
      _  , top => top;
      _  , _   => let left = drop(valLeft), right = drop(valRight) in
                    lift(min(left#1, right#1), max(left#2, right#2));
  endcase

  max :: snum * snum -> snum
  max(a,b) = if a > b then a else b endif

  min :: snum * snum -> snum
  min(a,b) = if a < b then a else b endif

  branch :: Expression * State * bool -> State
  branch(expression, state, edge) = let valexp = evalBExp(expression, state) in
    if valexp = top then state else if drop(valexp) = edge then state else bot endif endif
